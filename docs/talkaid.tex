\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{listings}
\usepackage{color}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[italian]{babel}
\usepackage[letterpaper,top=3cm,bottom=3cm,left=3cm,right=3cm]{geometry}
\usepackage{amsmath}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{fancyhdr}
\usepackage[T1]{fontenc}
\usepackage{imakeidx}
\makeindex[columns=3, title=Alphabetical Index, intoc]

\begin{document}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[C]{UNISA - TalkAID}

    \title{TalkAID}
    \author{
        Anna Benedetta Salerno\\
        \and
        Michele D'Arienzo\\
        \and
        Raffaele Monti\\
        \and
        Luigi Petrillo\\
        \and
        Samuele Sparno\\
    }
    \date{23 Gennaio 2024}

    \maketitle

    \pagebreak

    \tableofcontents

    \pagebreak
    
    \section{Sistema Attuale}

    Il progetto TALKAID rappresenta davvero un passo avanti significativo nel campo della riabilitazione e del supporto alle persone con disabilità del linguaggio. La possibilità di offrire trattamenti completamente \textit{a distanza} e in maniera \textit{asincrona} è un'innovazione che potrebbe aprire nuove opportunità per un numero ancora maggiore di individui affetti da queste patologie.

    La registrazione e il monitoraggio dei progressi dei pazienti potrebbe essere complessa e limitata a causa della mancanza di strumenti tecnologici dedicati.

    Inoltre i metodi tradizionali potrebbero non essere altamente personalizzati alle esigenze specifiche dei pazienti, poiché potrebbe essere difficile adattarli in modo rapido ed efficiente. Inoltre la necessità delle visite dal vivo può essere un ostacolo per coloro che abitano a grandi distanze dai centri logopedici oppure per i lavoratori.

    

    La componente di Intelligenza Artificiale è ritenuta fondamentale ai nostri obiettivi siccome aggiunge un livello di personalizzazione e adattabilità, permettendo ai pazienti di ricevere esercizi mirati in base al loro necessità ed esperienza. Questo non solo rende il trattamento più efficace, ma anche più agevole per i logopedisti, in quanto saranno aiutati dall'IA nella scelta degli esercizi migliori. I pazienti verranno incoraggiati a perseguire con impegno il percorso di miglioramento attraverso le loro statistiche.

    \section{Sistema Proposto}

    Lo scopo del nostro progetto è quello di realizzare un agente intelligente che possa:

    \begin{itemize}
        \item Consigliare un insieme di esercizi mirato per il paziente, basandosi sulle sue reali necessità;
        \item Migliorare il sistema di consigli nel tempo, facendolo evolvere sulla base delle esecuzioni degli esercizi fatti dal paziente, considerando fattori come valutazione, feedback etc.
    \end{itemize}

    Sarà quindi in grado di generare insiemi di esercizi anche per pazienti privi di esperienza, e di andare pari passo con l'andamento dei loro miglioramenti.

    \pagebreak

    \section{Specifica PEAS}

    Di seguito abbiamo elencato la specifca P.E.A.S. dell'agente intelligente.

    \subsection{Performance:}

    Le prestazioni dell’agente sono valutate attraverso le seguenti misure:

    \begin{itemize}
        \item La sua capacità di consigliare esercizi il più mirati possibile per il paziente in base alla patologia;
        \item Il punteggio dell'esercizio che il paziente ha effettuato su quell'esercizio.
    \end{itemize}

    \subsection{Environment:}

    L’ambiente è:

    \begin{itemize}
        \item \textit{Completamente osservabile}, in quanto si ha accesso a tutte le informazioni relative ai pazienti, in particolare le patologie, gli esercizi svolti e le informazioni sull'esecuzione degli esercizi come valutazione, feedback etc;
        \item \textit{Non deterministico}, in quanto lo stato dell’ambiente cambia indipendentemente dalle azioni dell’agente, come ad esempio cambiamento delle gravità delle patologie o esecuzioni di esercizi raccomandati dal logopedista curante;
        \item \textit{Sequenziale}, in quanto le esercitazioni effettuate dai pazienti e le scelte del logopedista influenzano le decisioni future dell’agente;
        \item \textit{Dinamico}, in quanto nel corso delle elaborazioni dell’agente, un paziente potrebbe svolgere un esercizio, cambiando in tal modo le sue esigenze;
        \item \textit{Discreto}, il numero di percezioni dell’agente è limitato in quanto ha un numero discreto di patologie, esercizi, pazienti, azioni e percezioni possibili;
        \item \textit{Singolo agente}, in quanto per il singolo paziente sarà l’unico agente che opera in questo ambiente è quello in oggetto.
    \end{itemize}

    \subsection{Actuators:}

    \begin{itemize}
        \item Salvataggio della lista di esercizi in un database, che sarà poi esposto in forma tabellare  al logopedista curante nella sua homepage, affinché quest'ultimo possa approvare o meno, per ogni paziente, i risultati dell'agente.
    \end{itemize}

    \subsection{Sensors:}

    \begin{itemize}
        \item L'agente accede ad un dataset, il quale è un riadattamento del database attualmente utilizzato dal sistema principale di TalkAID, eliminando gli attributi non necessari e aggiungendo gli attributi gravità di lettura e scrittura, necessari al fine di poter avere una più completa visualizzazione delle necessità reali del paziente. (Nella versione definitiva del sistema principale, gli attributi aggiunti per gravità di lettura e scrittura esisterebbero e verrebbero gestiti dal logopedista curante);
        
        \item Il dataset comprende informazioni e dati su:
            \begin{itemize}
                \item Le condizioni trattate dal sistema principale;
                \item Le esecuzioni di esercizi, che comprendono valutazione, feedback e data di completamento da parte dell'utente;
                \item Il glossario degli esercizi, con informazioni su difficoltà, target e tipologia;
                \item La gravità delle condizioni degli utenti.
            \end{itemize}

        

    \end{itemize}

    \pagebreak

    \section{Soluzione proposta}

    Date le nostre necessità, abbiamo potuto constatare che ciò di cui abbiamo bisogno è un algoritmo \textit{Genetico} di ottimizzazione.

    Nonostante un'attenta valutazione di vari algoritmi, tra i quali spicca l'utilizzo di tecniche come la segmentazione degli utenti o il collaborative filtering, in particolare il clustering potrebbe aiutare a limitare quali esercizi consigliare in base alle patologie del paziente. Purtroppo, al momento non esistono dataset pertinenti per la nostra valutazione, quindi disponiamo di un insieme di dati limitato e poco realistico, che non permette a un ipotetico algoritmo di apprendimento di effettuare un training ottimale.

    Abbiamo quindi optato per un algoritmo di ricerca locale genetico, poiché è in grado di individuare un punto ottimo tra le diverse alternative, producendo
    soluzioni sempre migliori rispetto a una funzione obiettivo, anche in assenza di un dataset molto esteso. È importante notare che ciò non garantisce l'ottimalità,
    dato che solitamente produce soluzioni sub-ottimali. Proprio per questo motivo, affidiamo il lavoro di supervisione al logopedista.

    Il nostro obiettivo è ottenere una lista di esercizi per ciascun paziente che possa soddisfare le sue specifiche esigenze. Questa lista sarà poi presa in
    considerazione dal logopedista. Di conseguenza, potremmo dire che ogni popolazione sarà associata ad un determinato
    paziente, i cui individui saranno un possibile insieme di esercizi raccomandati.

    \section{Raccolta e sviluppo del dataset}

    Avendo la necessità di utilizzare un dataset sul quale il nostro modello avrebbe dovuto estrapolare le informazioni riguardanti gli esercizi e i pazienti, la sfida consisteva in due opzioni:

    \begin{itemize}
        \item Cercare un dataset pre-esistente al fine di avere molte informazioni, e al massimo effettuare data cleaning e adeguarlo a quello che ci serve.
        \item Creare un dataset, formulando gli esercizi, aggiungendo i pazienti e creando le varie valutazioni per ogni esercizio.
    \end{itemize}

    Purtroppo la ricerca di un dataset pre-esistente non è stato proficuo data l'unicità delle nostre richieste; infatti, non abbiamo trovato dataset che riguardassero nel dettaglio la valutazione di esercizi logopedici.

    Di conseguenza, abbiamo deciso di creare un nostro dataset, utilizzando un database in MySQL e generando le varie tipologie di esercizi di nostra iniziativa, ottenendo \textit{84 esercizi}, divisi per \textit{7 diverse tipologie}, e una selezione di \textit{12 patologie} tra le più comuni e con difficoltà il più possibile incentrate principalmente sulla Scrittura o Lettura. La generazione dei pazienti e la generazione delle valutazioni degli esercizi sono state prodotte sinteticamente mediante l'utilizzo di valori randomici.

    \begin{itemize}
        \item Di seguito vengono mostrati i vari codici in SQL realizzati per poter popolare il nostro database.
    \end{itemize}

    \lstset{
        backgroundcolor=\color{white},
        basicstyle=\footnotesize,
        breakatwhitespace=false,
        breaklines=true,
        captionpos=b,
        commentstyle=\color{dkgreen},
        deletekeywords={...},
        escapeinside={\%*}{*)},
        extendedchars=true,
        frame=single,
        keepspaces=true,
        language=SQL,
        otherkeywords={is},
        morekeywords={*,modify,MODIFY,...},
        keywordstyle=\keywordcheck,
        identifierstyle=\setidcolor,
        numbers=left,
        numbersep=15pt,
        numberstyle=\tiny,
        rulecolor=\color{ltgray},
        showspaces=false,
        showstringspaces=false,
        showtabs=false,
        stepnumber=1,
        tabsize=4,
        title=\lstname
    }

    \pagebreak

    \subsection{Popolazione del DataBase}

    \begin{lstlisting}[language=SQL, breaklines, caption=Generazione Casuale esecuzione esercizio]
        INSERT INTO exercise (ID_user, ID_exercise, InsertionDate, CompletionDate, Evaluation, Feedback)
        VALUES
        (
            FLOOR(904 + RAND() * (1003 - 904 + 1)), -- Random user ID
            FLOOR(1 + RAND() * (84 - 1 + 1)), -- Random exercise ID
            DATE_SUB(NOW(), INTERVAL FLOOR(RAND() * 365) DAY), -- Random date within the past year
            DATE_SUB(NOW(), INTERVAL FLOOR(RAND() * 365) DAY), -- Random completion date within the past year
            FLOOR(RAND() * (100 - 0 + 1)), -- Random evaluation between 0 and 100
            CASE
                WHEN RAND() <= 0.33 THEN -1
                WHEN RAND() <= 0.66 THEN 0
                ELSE 1
            END -- Random feedback (-1, 0, or 1)
        );
    \end{lstlisting}

    \begin{lstlisting}[language=SQL, breaklines, caption=Generazione degli utenti]
        DELIMITER //

        CREATE PROCEDURE GenerateUsers()
        BEGIN
            DECLARE i INT DEFAULT 1;
            DECLARE j INT;

            WHILE i <= 10 DO -- For each therapist user
                SET j = 1;
                WHILE j <= 10 DO -- Create 10 patient users
                    INSERT INTO user (ID_Therapist) VALUES (i); 
                    SET j = j + 1;
                END WHILE;
                SET i = i + 1;
            END WHILE;
        END //

        DELIMITER ;

        CALL GenerateUsers();
    \end{lstlisting}

    \pagebreak

    \begin{lstlisting}[language=SQL, breaklines, caption=Generazione delle Writing e Reading severity (tutti i pazienti)]
        INSERT INTO patientcondition (ID_condition, ID_patient, Severity, WritingSeverity, ReadingSeverity)
        SELECT
            FLOOR(1 + RAND() * 12) as ID_condition,  -- Random condition ID (1 to 12)
            u.ID as ID_patient,
            1 as Severity,
            FLOOR(1 + RAND() * 10) as WritingSeverity,
            FLOOR(1 + RAND() * 10) as ReadingSeverity
        FROM
            user u
        WHERE
            u.ID_Therapist != 0;
    \end{lstlisting}

    \begin{lstlisting}[language=SQL, breaklines, caption=Generazione delle Writing e Reading severity (solo per 30 pazienti)]
        INSERT INTO patientcondition (ID_condition, ID_patient, Severity, WritingSeverity, ReadingSeverity)
        SELECT
            FLOOR(1 + RAND() * 12) as ID_condition,  -- Random condition ID (1 to 12)
            u.ID as ID_patient,
            1 as Severity,
            FLOOR(1 + RAND() * 10) as WritingSeverity,
            FLOOR(1 + RAND() * 10) as ReadingSeverity
        FROM
            user u
        WHERE
            u.ID_Therapist != 0
        ORDER BY
            RAND()  -- Randomly order the users and pick the first one
        LIMIT 30;
    \end{lstlisting}

    \begin{lstlisting}[language=SQL, breaklines, caption=Generazione della General severity (tutti i pazienti)]
        UPDATE patientcondition pc
        SET
            pc.Severity = LEAST(GREATEST(pc.WritingSeverity, pc.ReadingSeverity) + IF(RAND() < 0.5, -1, 1), 10)
        WHERE
            pc.Severity = 1;
    \end{lstlisting}

    La necessità di generare in due modi diversi le patologie degli utenti (una volta per tutti i pazienti, una volta solo per 30 pazienti) , è dovuta alla concreta possibilità di pazienti con più di una patologia, come ad esempio \textit{Dislessia} e \textit{Disgrafia}.

    \pagebreak

    \subsection{Analisi del DataBase}
    In questa sezione, illustriamo il processo di ideazione delle tabelle, riportando il loro nome, descrivendone la funzione e indicando gli attributi contenuti.

\begin{itemize}
\item     condition - Contiene tutte le informazioni sulle patologie trattate dal sistema, importante per le relazioni tra esercizi e patologie.
\end{itemize}

    \begin{table}[h]
        \centering
        \caption{condition Table}
        \begin{tabular}{|c|p{8cm}|}
            \hline
                \textbf{Attributo} & \textbf{Descrizione} \\
            \hline
                ID\_condition & id della patologia\\
            \hline
                Description & serve per capire cosa provoca la patologia, non è un dato rilevante per il nostro agente\\
            \hline
                Name & nome della patologia\\
            \hline
        \end{tabular}
    \end{table}

\begin{itemize}
\item    exercise - Contiene tutti gli esercizi assegnati e/o svolti, utile per poter tenere traccia dell'andamento dei vari pazienti.
\end{itemize}

    \begin{table}[h]
        \centering
        \caption{exercise Table}
        \begin{tabular}{|c|p{8cm}|}
            \hline
                \textbf{Attributo} & \textbf{Descrizione} \\
            \hline
                ID\_user & id del paziente associato all'esercizio\\
            \hline
                ID\_exercise & id dell'esercizio che ha svolto il paziente\\
            \hline
                InsertionDate & data di assegnazione dell'esercizio da parte del logopedista\\
            \hline
                CompletionDate & data di completamento dell'esercizio\\
            \hline
                Evaluation & che punteggio il paziente ha raggiunto\\
            \hline
                Feedback & feedback per mostrare se l'esercizio è piaciuto o meno\\
            \hline
        \end{tabular}
    \end{table}

\pagebreak

\begin{itemize}
\item     exercise\_glossary - Contiene le varie informazioni specifiche degli esercizi, interessante poiché ci permette di poter trovare il target specifico di un determinato esercizio, o la sua difficoltà.
\end{itemize}

    \begin{table}[h]
        \centering
        \caption{execise\_glossary Table}
        \begin{tabular}{|c|p{8cm}|}
            \hline
            \textbf{Attributo} & \textbf{Descrizione} \\
            \hline
                ID\_exercise & id dell'esercizio\\
            \hline
                ExerciseName & nome dell'esercizio\\
            \hline
                ExerciseDescription & breve descrizione dell'esercizio\\
            \hline
                Type & tipo dell'esercizio, può essere un esercizio di lettura testo, associare immagini, trovare la frase corretta etc...\\
            \hline
                Difficulty & grado di difficoltà dell'esercizio\\
            \hline
                Target & il target è la patologia alla quale questo esercizio è mirato\\
            \hline
        \end{tabular}
    \end{table}

\begin{itemize}
\item     patient\_condition - Contiene le informazioni riguardo la patologia che affligge il paziente, in base a questa il nostro agente potrà selezionare esercizi specifici per il paziente.
\end{itemize}

    \begin{table}[h]
        \centering
        \caption{patient\_condition Table}
        \begin{tabular}{|c|p{8cm}|}
            \hline
            \textbf{Attributo} & \textbf{Descrizione} \\
            \hline
                ID\_condition & id della patologia affetta dal paziente\\
            \hline
                ID\_patient & id del paziente riferito\\
            \hline
                Severity & gravità della patologia del paziente \\
            \hline
                WritingSeverity & gravità della condizione del paziente nello scrivere\\
            \hline
                ReadingSeverity & gravità della condizione del paziente nel leggere\\
            \hline
        \end{tabular}
    \end{table}

\pagebreak

    \subsection{Interazioni con il DataBase}
    Le interazioni effettuate dal nostro agente sul database sono esclusivamente operazioni di estrapolazione dati. Elencando, le funzioni create sono:

    
    Per quanto riguarda le estrazioni degli esercizi:
    \begin{itemize}
        \item\textbf{select\_exercises\_not\_done}: Questa funzione permette di ottenere gli esercizi non ancora svolti dall'paziente.

        \item\textbf{select\_done\_exercises}: Questa funzione permette il recupero egli esercizi svolti dal paziente.

        \item\textbf{select\_random\_exercise}: Questa funzione recupera casualmente alcuni esercizi e, nel caso in cui vi siano esercizi precedentemente completati dal paziente, restituisce anche i relativi risultati.

    \end{itemize}
    Per quanto riguarda le estrazioni dei pazienti:
    \begin{itemize}
        \item\textbf{informationUser}: Questa funzione permette il recupero di informazioni inerenti alle varie patologie che il paziente è affetto con i livelli di gravità per ogniuna di essa.

    \end{itemize}

\pagebreak

    \section{Studio della funzione di fitness}
    Da qui cominciamo a descrivere lo studio che è stato effettuato per poter sviluppare la funzione di fitness. Essa è basata su varie informazioni inerenti al paziente, agli esercizi e la loro ultima esecuzione, se esiste. 
    
    Più precisamente, le seguenti calcolano la fitness unicamente dall'esercizio e necessità dell'utente:

\begin{itemize}

\item\textbf{difficultBasedFitness}: Restituisce un valore sulla base della difficoltà del singolo esercizio. Per prima cosa otteniamo l'esperienza dell'utente andando a calcolare la \textit{mediana} della difficoltà degli ultimi 50 esercizi svolti. Calcoliamo poi la media delle General Severity delle condition del paziente. Quando più è alta questa media, più lenta deve essere la curva di crescita della difficoltà, rispetto all'esperienza. Se la difficoltà rientra nella curva di crescita, restituisce 100, altrimenti un valore sempre più basso quanto si discosta. (Nel caso di utente con zero esperienza, il valore di experience è uguale a 0).
\begin{lstlisting}
    def difficultBasedFitness(e: Exercise, u: User) -> float:
        difficulty = e.getExerciseDifficulty()
        severity = fu.getMeanSeverity(u)
        experience = fu.getExperience(u)
        maxD, minD = fu.getMaxMinExperience(u)
    
        distance = abs(difficulty - experience)
        slope = fu.getSlope(severity)
    
        if distance < difficulty <= distance + slope:
            value = 100
        else:
            value = 100 - (distance / (maxD - minD) * 100)
        return value
\end{lstlisting}


\item\textbf{severityBasedFitness}: Restituisce un valore da 0 a 100 sulla base della tipologia (Lettura o Scrittura) dell'esercizio e la gravità del paziente in tale ambito.
\begin{lstlisting}
    def severityBasedFitness(e: Exercise, u: User) -> float:
    if e.getExerciseType() == "READTEXT" or e.getExerciseType() == "TEXTTOIMAGES" or e.getExerciseType() == "READIMAGES":
        value = fu.getMeanReadingSeverity(u)
    else:
        value = fu.getMeanWritingSeverity(u)

    return value * 10
\end{lstlisting}



\item\textbf{targetBasedFitness}: Restituisce un valore che va da 0 a 100 in base all'adeguatezza dell'esercizio per le patologie affette del paziente.
\begin{lstlisting}
    def targetBasedFitness(e: Exercise, u: User) -> float:
    rightTarget = 0
    for key in u.getConditions().keys():
        if key in e.getExerciseTarger():
            rightTarget += 1

    return (rightTarget / len(e.getExerciseTarger().split(","))) * 100
\end{lstlisting}

\pagebreak

\item\textbf{evaluateBasedFitness}: La funzione restituisce un valore che va da 0 a 100 ottenuto sottraendo la votazione massima che si può avere da un'esecuzione, e la votazione che il paziente ha avuto su quell'esercizio.
\begin{lstlisting}
    def evaluateBasedFitness(e: Exercise) -> float:
    if e.getLastEvaluation() is not None:
        value = 100 - e.getLastEvaluation()
    else:
        value = 100
    return value
\end{lstlisting}

\item\textbf{dateBasedFitness}: Restituisce un valore sulla base della quantità di tempo passata dalla data odierna alla data di completamento del esercizio.
\begin{lstlisting}
    def dateBasedFitness(e: Exercise, maxDays: int) -> float:
    value = 100
    if e.getLastCompletionDate() is not None:
        completionDate = datetime.strptime(e.getLastCompletionDate(), "%Y-%m-%d")
        data_odierna = datetime.now()
        giorni_passati = (data_odierna - completionDate).days
        if giorni_passati < maxDays:
            value = fu.getDaysValue(giorni_passati, maxDays)
    return value
\end{lstlisting}









\item\textbf{feedbackBasedFitness}: Restituisce un valore in base al feedback del paziente, quindi controlla se il paziente ha ricevuto un esercizio che gli aggrada e che gli è stato utile.
\begin{lstlisting}
    def feedbackBasedFitness(e: Exercise) -> float:
    if e.getLastFeedback() is not None:
        if e.getLastFeedback() > 0:
            return 100
        else:
            return 0
    else:
        return 100
\end{lstlisting}

\item\textbf{last50Fitness}: Valuta se l'esercizio offerto all'paziente è compreso negli ultimi 50 esercizi fatti, in caso negativo verrà riproposto.
\begin{lstlisting}
    def last50Fitness(e: Exercise, u: User) -> float:
    if e.getExerciseID() in u.getExercises().keys():
        position = 0
        for index, ID in enumerate(u.getExercises().keys()):
            if ID == e.getExerciseID():
                position = index
                break
        return fu.getPositionValue(position)
    else:
        return 100
\end{lstlisting}
\end{itemize}

\pagebreak

Tutti questi dati sono di vario tipo e di varia importanza, infatti ogni dato nel calcolo del valore fitness è moltiplicato con una costante di importanza dedicata.
\begin{lstlisting}
    def fitness(ex: Exercise, u: User) -> float:
    f1, f2, f3, f4, f5, f6, f7 = F1, F2, F3, F4, F5, F6, F7

    somma = (f1 * evaluateBasedFitness(ex)) + (f2 * dateBasedFitness(ex, MDAYS)) + (f3 * difficultBasedFitness(ex, u))
    somma += (f4 * severityBasedFitness(ex, u)) + (f5 * targetBasedFitness(ex, u))
    somma += (f6 * feedbackBasedFitness(ex)) + (f7 * last50Fitness(ex, u))

    # somma = (f3 * difficultBasedFitness(ex, u))
    # somma += (f4 * severityBasedFitness(ex, u))
    # somma += (f5 * targetBasedFitness(ex, u)) <- Only exercise info, ignores executions from user

    return somma
\end{lstlisting}

Tale variabile è modificabile in modo tale che il logopedista può decidere se considerare un dato rispetto ad un altro in base alle proprie esigenze.

\pagebreak

I dati su cui noi eseguiamo l'algoritmo GA è Popolation. Tale dato è strutturato da vari campi ognuno caratterizzato da parametri e le funzioni di modifica e visualizzazione dei singoli parametri, più precisamente queste classi sono:

\begin{itemize}

\item\textbf{user}: informazioni inerenti al paziente, come le sue patologie

\item\textbf{individuals}: una lista di set di esercizi da elaborare

\item\textbf{entirefitness}: valore fitness dell'intero Popolation

\end{itemize}

\bigskip
La size della popolazione è fissa, ovviamente puo' essere modificata ma una volta inizializzato il ga la dimensione rimane tale.
Dato che abbiamo implementato sia crossover a 2 che a 3 genitori, l'unica accortezza è scegliere una dimensione tale che possa permettere appunto il crossover scelto (esempio, se la popolazione è dispari e si prova a fare crossover a 2 genitori il ga potrebbe avere errori imprevisti)
\bigskip

User è caratterizzato da:
\begin{itemize}
\item\textbf{ID}: indicante l'id identificativo del paziente
\item\textbf{conditions}: lista di patologie del paziente
\item\textbf{exercises}: ultimi 50 esercizi fatti dal paziente
\begin{lstlisting}
    class User:
    def __init__(self, ID: int, conditions: dict, exercises: dict):
        
        self._ID = ID
        self._conditions = conditions
        self._exercises = exercises
\end{lstlisting}
\end{itemize}

\bigskip

Conditions è un dizionario caratterizzato da:
\begin{itemize}
\item\textbf{Key}: nome della patologia
\item\textbf{value}: una tupla che indica la gravità della patologia nei tre aspetti Severity(gravità generale), SeverytyWrite(gravità nella scrittura) e SeverityRead(gravità nella lettura)
\end{itemize}

Gli individui rappresenta un set di esercizi e il vlaore di fitness del set.

Ogni esercizio è anch'esso un'istanza della classe esercizio che ha al suo interno tutte le informazioni dell'esercizio generale, sia le eventuali informazioni inerenti all'ultima esecuzione da parte dell'paziente del determinato esercizio.

\bigskip

Più precisamente Individual è caratterizzato:
\begin{itemize}
\item\textbf{individualFitness}: valore fitness del singolo set di esercizi
\item\textbf{exercises}: l'insieme di esercizi che compongono il set di esercizi
\begin{lstlisting}
    class Individual:
    def __init__(self, *args: Exercise):
        self._individualFitness = 0
        self._exercises = list()
        for ex in args:
            self._exercises.append(ex)
\end{lstlisting}
\end{itemize}

\pagebreak

I singoli esercizi sono caratterizzati da:
\begin{itemize}
\item\textbf{fitness}: valore fitness calcolato del singolo esercizio
\item\textbf{generation}: indicante a quando è stato generato l'esercizio e inserito nel set
\item\textbf{ID}: id unico del'esercizio
\item\textbf{exerciseDifficulty}: difficolta dell'esercizio
\item\textbf{target}: indica a quale tipologia di patologie è meglio dedicata l'esercizio
\item\textbf{type}: indica il tipo di esercizio(lettura, scrittura...)
\item\textbf{lastEvaluation}: indicante l'ultima vlalutazioen dell'esercizio se questo è stato già eseguito dal paziente
\item\textbf{lasCompletionDate}: indicante l'ultima data in cui è stato fatto l'esercizio
\item\textbf{lastFeedback}: Feedback lasciato dal paziente all'esercizio
\end{itemize}
\begin{lstlisting}[language=Python, breaklines, no caption]
    class Exercise:
    def __init__(self, ID: int, exerciseDifficulty: int, target: str, exType: str,
                 lastEvaluation: int | None, lastCompletionDate: str | None, lastFeedback: int | None):
        self._fitnessValue = 0
        self._generation = 0
        self._exerciseID = ID
        self._exerciseDifficulty = exerciseDifficulty
        self._target = target
        self._exType = exType
        self._lastEvaluation = lastEvaluation
        self._lastCompletionDate = lastCompletionDate
        self._lastFeedback = lastFeedback

\end{lstlisting}


\pagebreak


\section{Sviluppo del nostro algoritmo genetico}

Vista la dimensione del nostro gruppo abbiamo anche deciso di imlementare e provare diversi algoritmi per le diverse fasi dell'algoritmo Genetico.

L'algoritmo genetico è suddiviso nelle fasi di Selezione, Crossover e Mutaizone.

\subsection{Scelte progettuali}

\begin{itemize}
\item La size della popolazione è fissa, ovviamente puo' essere modificata, ma una volta inizializzato il ga la dimensione è rimane tale.
Dato che abbiamo implementato sia crossover a 2 che a 3 genitori, l'unica accortezza è scegliere una dimensione tale che possa permettere appunto il crossover scelto (esempio, se la popolazione è dispari e si prova a fare crossover a 2 potrebbe portare problemi all'agente).

\item La size mating pool è grande quanto il numero di individui, non ci interessa la lentezza dato che, oltre al fatto che verrà eseguito sempre in orari in cui il tempo di esecuzione non è un problema (quindi quando l'paziente ha già esercizi da fare / quando il logopedista ha già degli esercizi da valutare). 

Inoltre l'abbiamo reso multiprocessing quindi può eseguire in parallelo più utenti, quindi il le performance temporali non sono un problema.

\item La probabilità di crossover dipende dal tipo di crossover scelto, infatti abbiamo crossover dove è certo che accada, crossover dove puoi specificare la probabilità.

\item La probabilità di mutazione è scelta prima dell'inizio del ga.

\item Gli individui sono una classe, essa ha il valore di fitness dell'individuo e una lista di istanze di esercizi.

\begin{itemize}

\item Ogni esercizio è anch'esso un'istanza della classe esercizio che ha al suo interno tutte le informazioni dell'esercizio generale, sia le eventuali informazioni inerenti all'ultima esecuzione da parte del paziente del determinato esercizio.

\end{itemize}

\item Per la selezione abbiamo sviluppato sia l'algoritmo roulette Wheel (ma abbiamo notato che spesso porta a convergenza prematura), che rank selection, il quale risolve il problema della convergenza prematura.

\item Crossover ne abbiamo sviluppati diversi:

\begin{itemize}

\item nPoint e nPointReverse dove è possibile specificare il numero di punti. La differenza tra nPoint e nPointReverse è che nPointReverse inizia con uno scambio.

\item Oltre questo abbiamo anche sviluppato la versione con probabilità di crossover, e anche qui si può scegliere la probabilità di crossover.

\item Infine anche uniformCrossover, che essenzialmente è nPoint dove n=lunghezza.

\end{itemize}

\item Come mutazione abbiamo implementato mutazione del singolo gene (singolo esercizio a caso ad un singolo individuo a caso), un intero individuo a caso viene completamente cambiato e infine il peggior individuo viene completamente cambiato .

\begin{itemize}
\item Anche qui, si può decidere la probabilità di mutazione
\end{itemize}

\item Stopping condition abbiamo sia dopo tot generazioni, sia se la fitness della popolazione non aumenta per x generazioni di y.
Ovviamente si può usare una sola condizione o entrambe insieme.
\end{itemize}

\bigskip

\subsection{Selezione}

Nella fase di selezione abbiamo implementato 3 tipi diversi di algoritmi:

\begin{itemize}
\item\textbf{Roulette Wheel}: Sfruttiamo il valore della funzione di fintess di ogni elemento per impostare la probabilità che venga scelto.

Poi tramite un sorteggio randomico di un numero verrà prelevato l'elemento che passera' alla generazione successiva.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def rouletteWheel(population: Population):
    user = population.getUser()
    totalFitness = 0
    for i in population.getIndividuals():
        evaluate(i, user)
        totalFitness += i.fitness()

    newIndividuals = list()
    while len(newIndividuals) < len(population):
        value = random.random() * totalFitness
        comulativeFitness = 0
        for i in population.getIndividuals():
            comulativeFitness += i.fitness()
            if comulativeFitness >= value:
                newIndividuals.append(Individual(*i.getList()))
                break
    return newIndividuals
\end{lstlisting}

\begin{itemize}
\item\textbf{Rank Selection}: Questo metodo sfrutta il rango di ciascun elemento per suddividere una "torta" di selezione in partizioni proporzionali al rango dell'elemento. Il rango varia dal più basso al più alto, con la percentuale di possibilità di essere selezionato proporzionata al rango. Questa metodologia riesce a escludere meno elementi rispetto alla roulette, poiché la percentuale è legata agli elementi e non al valore di fitness. Per individuare i ranghi degli elementi, viene utilizzata la funzione findRank.

\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def rankSelection(population: Population):
    user = population.getUser()
    for i in range(len(population)):
        evaluate(population[i], user)

    sortedIndividuals = sorted(population.getIndividuals(), key=lambda ind: ind.fitness())

    newPopolation = list()
    size = len(sortedIndividuals)
    subdivision = (size * (size+1))/2

    while len(newPopolation) < len(population):
        newPopolation.append(su.find_rank(sortedIndividuals, subdivision))
    return sortedIndividuals
---------------------------------------------------------------------------------------
def find_rank(individuals: list[Individual], subdivision: float) -> Individual:
    num = random.randint(1, 100)
    prec = 0
    for i in range(1, len(individuals)):
        if prec < num <= (100/subdivision)*i:
            return Individual(*individuals[i].getList())
        else:
            prec = (100/subdivision)*i
\end{lstlisting}

\pagebreak

\begin{itemize}

\item\textbf{item Random Selection}: La selezione attuata è completamente casuale; in effetti, l'assenza di una logica sottostante può generare dati del tutto inefficienti.

\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def randomSelection(population: Population):
    newP = []
    while len(newP) < len(population):
        newP.append(random.choice(population))
    return newP
        \end{lstlisting}

\subsection{Crossover}

La fase di Crossover impiega algoritmi per generare nuovi elementi a partire da quelli selezionati nella fase precedente.

Le tipologie di Crossover non sono state categorizzate solo in base al tipo, ma anche al numero di elementi da impiegare.

\subsubsection {Metodologie di Crossover applicate a 3 elementi}

\begin{itemize}
\item\textbf{nPoint}: Il Crossover in questione modifica n punti all'interno di 3 liste di esercizi. Ciascuna lista viene suddivisa in sottoliste più piccole, le quali rappresentano i punti che saranno combinati con gli analoghi punti nelle altre liste.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def nPoint(i1: Individual, i2: Individual, i3: Individual, n: int) -> tuple[Individual, Individual, Individual]:
    if len(i1) != len(i2) != len(i3):
        raise ValueError("Invalid individual length! They have to be the same.")
    elif n > len(i1):
        raise ValueError("Invalid n value, must be less than the lenght of the individual!")

    dividedI1, dividedI2, dividedI3 = divide(i1.getList(), n), divide(i2.getList(), n), divide(i3.getList(), n)

    newI1 = list()
    newI2 = list()
    newI3 = list()

    for i, triplet in enumerate(zip(dividedI1, dividedI2, dividedI3)):
        if i % 3 == 0:
            newI1.extend(triplet[0])
            newI2.extend(triplet[1])
            newI3.extend(triplet[2])
        elif i % 3 == 1:
            newI1.extend(triplet[2])
            newI2.extend(triplet[0])
            newI3.extend(triplet[1])
        elif i % 3 == 2:
            newI1.extend(triplet[1])
            newI2.extend(triplet[2])
            newI3.extend(triplet[0])

    i1.setList(newI1)
    i2.setList(newI2)
    i3.setList(newI3)

    return i1, i2, i3
\end{lstlisting}

\pagebreak

\begin{itemize}
\item\textbf{nPointReverse}: La procedura di Crossover modifica n punti all'interno di 3 liste di esercizi. Ciascuna lista viene suddivisa in sottoliste con un numero ridotto di elementi; queste ultime costituiscono i punti che saranno combinati con quelli delle altre liste, ma seguendo un ordine diverso rispetto a quanto avviene con nPoint.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def nPointReverse(i1: Individual, i2: Individual, i3: Individual, n: int) -> tuple[Individual, Individual, Individual]:
    if len(i1) != len(i2) != len(i3):
        raise ValueError("Invalid individual length! They have to be the same.")
    elif n > len(i1):
        raise ValueError("Invalid n value, must be less than the lenght of the individual!")

    dividedI1, dividedI2, dividedI3 = divide(i1.getList(), n), divide(i2.getList(), n), divide(i3.getList(), n)

    newI1 = []
    newI2 = []
    newI3 = []

    for i, triplet in enumerate(zip(dividedI1, dividedI2, dividedI3)):
        if i % 3 == 0:
            newI1.extend(triplet[1])
            newI2.extend(triplet[2])
            newI3.extend(triplet[0])
        elif i % 3 == 1:
            newI1.extend(triplet[0])
            newI2.extend(triplet[1])
            newI3.extend(triplet[2])
        elif i % 3 == 2:
            newI1.extend(triplet[2])
            newI2.extend(triplet[0])
            newI3.extend(triplet[1])

    i1.setList(newI1)
    i2.setList(newI2)
    i3.setList(newI3)

    return i1, i2, i3
        \end{lstlisting}

        \pagebreak

\begin{itemize}
\item\textbf{nPointRandom}: Questo Crossover va a modificare n punti di 3 liste di esercizi, ogni lista è sarà suddivisa in sottoliste di meno elementi queste'ultime rappresentano i punti che saranno combinati con gli altri ma in ordine casuale.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def nPointRandom(i1: Individual, i2: Individual, i3: Individual, n: int, crossoverProbability: float) -> tuple[Individual, Individual, Individual]:
    if len(i1) != len(i2) != len(i3):
        raise ValueError("Invalid individual length! They have to be the same.")
    elif n > len(i1):
        raise ValueError("Invalid n value, must be less than the lenght of the individual!")
    elif crossoverProbability < 0 or crossoverProbability > 1:
        raise ValueError("Invalid crossoverProbability! Must be between 0 and 1")

    dividedI1, dividedI2, dividedI3 = divide(i1.getList(), n), divide(i2.getList(), n), divide(i3.getList(), n)

    newI1 = []
    newI2 = []
    newI3 = []

    for triplet in zip(dividedI1, dividedI2, dividedI3):
        if random() < crossoverProbability:
            i = randint(0, 2)
            if i % 3 == 0:
                newI1.extend(triplet[0])
                newI2.extend(triplet[1])
                newI3.extend(triplet[2])
            elif i % 3 == 1:
                newI1.extend(triplet[2])
                newI2.extend(triplet[0])
                newI3.extend(triplet[1])
            elif i % 3 == 2:
                newI1.extend(triplet[1])
                newI2.extend(triplet[2])
                newI3.extend(triplet[0])

    i1.setList(newI1)
    i2.setList(newI2)
    i3.setList(newI3)

    return i1, i2, i3
        \end{lstlisting}

\pagebreak

\subsubsection {Metodologie di Crossover eseguite su 2 elementi}

\begin{itemize}
\item\textbf{nPoint}: Questo Crossover va a modificare n punti di 2 liste di esercizi, ogni lista sarà suddivisa in sottoliste di meno elementi queste'ultime rappresentano i punti che saranno combinati con gli altri.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def nPoint(i1: Individual, i2: Individual, n: int) -> tuple[Individual, Individual]:
    if len(i1) != len(i2):
        raise ValueError("Invalid individual length! They have to be the same.")
    elif n > len(i1):
        raise ValueError("Invalid n value, must be less than the lenght of the individual!")

    dividedI1, dividedI2 = divide(i1.getList(), n), divide(i2.getList(), n)

    newI1 = list()
    newI2 = list()

    for i, pair in enumerate(zip(dividedI1, dividedI2)):
        if i % 2 == 0:
            newI1.extend(pair[0])
            newI2.extend(pair[1])
        else:
            newI1.extend(pair[1])
            newI2.extend(pair[0])

    i1.setList(newI1)
    i2.setList(newI2)

    return i1, i2
        \end{lstlisting}

\begin{itemize}
\item\textbf{nPointReverse}: Questo Crossover va a modificare n punti di 2 liste di esercizi, ogni lista è sarà suddivisa in sottoliste di meno elementi queste'ultime rappresentano i punti che saranno combinati con gli altri ma in ordine diverso a nPoint.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def nPointReverse(i1: Individual, i2: Individual, n: int) -> tuple[Individual, Individual]:
    if len(i1) != len(i2):
        raise ValueError("Invalid individual length! They have to be the same.")
    elif n > len(i1):
        raise ValueError("Invalid n value, must be less than the lenght of the individual!")

    dividedI1, dividedI2 = divide(i1.getList(), n), divide(i2.getList(), n)

    newI1 = []
    newI2 = []

    for i, pair in enumerate(zip(dividedI1, dividedI2)):
        if i % 2 == 0:
            newI1.extend(pair[1])
            newI2.extend(pair[0])
        else:
            newI1.extend(pair[0])
            newI2.extend(pair[1])

    i1.setList(newI1)
    i2.setList(newI2)

    return i1, i2
\end{lstlisting}

\pagebreak

\begin{itemize}
\item\textbf{nPointRandom}: Questo Crossover va a modificare n punti di 2 liste di esercizi, ogni lista è sarà suddivisa in sottoliste di meno elementi queste'ultime rappresentano i punti che saranno combinati con gli altri ma in ordine casuale.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def nPointRandom(i1: Individual, i2: Individual, n: int,  crossoverProbability: float) -> tuple[Individual, Individual]:
    if len(i1) != len(i2):
        raise ValueError("Invalid individual length! They have to be the same.")
    elif n > len(i1):
        raise ValueError("Invalid n value, must be less than the lenght of the individual!")
    elif crossoverProbability < 0 or crossoverProbability > 1:
        raise ValueError("Invalid crossoverProbability! Must be between 0 and 1")

    dividedI1, dividedI2 = divide(i1.getList(), n), divide(i2.getList(), n)

    newI1 = []
    newI2 = []

    for i, pair in enumerate(zip(dividedI1, dividedI2)):
        if random() < crossoverProbability:
            newI1.extend(pair[1])
            newI2.extend(pair[0])
        else:
            newI1.extend(pair[0])
            newI2.extend(pair[1])

    i1.setList(newI1)
    i2.setList(newI2)

    return i1, i2
\end{lstlisting}

\pagebreak

\begin{itemize}
\item\textbf{unifromCrossover}: Questo Crossover va a modificare n punti di 2 liste di esercizi, ogni sottolista viene suddivisa nei suoi singoli di esercizi e queste suddivisioni potrebbero essere scambiate tra le 2 liste .
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def uniformCrossover(i1: Individual, i2: Individual, crossoverProbability: float) -> tuple[Individual, Individual]:
    if len(i1) != len(i2):
        raise ValueError("Invalid individual length! They have to be the same.")
    elif crossoverProbability < 0 or crossoverProbability > 1:
        raise ValueError("Invalid crossoverProbability! Must be between 0 and 1")

    dividedI1, dividedI2 = divide(i1.getList(), len(i1)), divide(i2.getList(), len(i2))

    newI1 = []
    newI2 = []

    for i, pair in enumerate(zip(dividedI1, dividedI2)):
        if random() < crossoverProbability:
            newI1.extend(pair[1])
        else:
            newI1.extend(pair[0])

        if random() < crossoverProbability:
            newI2.extend(pair[0])
        else:
            newI2.extend(pair[1])

    i1.setList(newI1)
    i2.setList(newI2)

    return i1, i2
\end{lstlisting}

\pagebreak

Queste tipologie di Crossover sono eseguite da:

\begin{itemize}
\item\textbf{executeCrossover}: Questa funzione esegue il Crossover su una popolazione, la popolazioen rappresenta un insieme di informazioni inerenti all'paziente e ad una lista di esercizi.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def executeCrossover(p: Population, crossoverType: crossover, *args) -> list[Individual]:
    newIndividuals = list()
    individuals = p.getIndividuals()
    size = len(p)

    if size % 2 != 0:
        raise ValueError("The size of the population must be even!")
    else:
        for _ in range(round(len(p) / 2)):
            i1 = random.choice(individuals)
            p.removeIndividual(i1)
            i2 = random.choice(individuals)
            p.removeIndividual(i2)
            i1, i2 = crossoverType(i1, i2, *args)
            newIndividuals.append(i1)
            newIndividuals.append(i2)

        return newIndividuals
\end{lstlisting}

\begin{itemize}
\item\textbf{execute3Crossover}: Questa funzioen esegue il Crossover su 3 popolazioen che invece di 2 così da effettuare combinazioni più rillevanti.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def execute3Crossover(p: Population, crossoverType: crossover, *args) -> list[Individual]:
    newIndividuals = list()
    individuals = p.getIndividuals()
    size = len(p)

    if size % 3 != 0:
        raise ValueError("The size of the population must be divisible by 3!")
    else:
        for _ in range(round(len(p) / 3)):
            i1 = random.choice(individuals)
            p.removeIndividual(i1)
            i2 = random.choice(individuals)
            p.removeIndividual(i2)
            i3 = random.choice(individuals)
            i1, i2, i3 = crossoverType(i1, i2, i3, *args)
            newIndividuals.append(i1)
            newIndividuals.append(i2)
            newIndividuals.append(i3)

        return newIndividuals
\end{lstlisting}

Tutte queste funzionalità vengono effettuate sfruttando la funzione divide che alla ricezioen di ua lista di esercizi essa viene suddivisa in una lista di liste formate dagli esercizi della lista originale, questa fuznioen permette la suddivisione della lista in punti che poi saranno usati dai Crossover.

\pagebreak

\subsection{Mutazione}

La mutazione è quella fase degli algoritmi GA che esegue una modifica al singolo dato, tale modifica può portare sia ad un vanaggio che ad un svantaggio, dipende dal tipo di algoritmo che viene usato, quelli da noi sviluppati sono:

\begin{itemize}
\item\textbf{randomSingleMutation}: Questa funzione può eseguire una mutazione su un esercizio di una popolazione. Se viene effettuate richiama la funzieon mutateEX.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
import random
from GA.Population.exercisePopulation import Population
import GA.Mutation.mutationUtility as mu

def randomSingleMutation(p: Population, mutationRate: float) -> Population:
    if random.random() < mutationRate:
        i = random.choice(p.getIndividuals())
        p.replaceIndividual(i, mu.mutateEx(i, p))

    return p
\end{lstlisting}

\begin{itemize}
\item\textbf{randomIndividualMutation}: Questa fuznione può eseguire una mutazione sull'intero set di esercizi di una popolazione, se la mutazioen accade richiama la funzione mutateIndividual.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def randomIndividualMutation(p: Population, mutationRate: float) -> Population:
    individuals = p.getIndividuals()

    if random.random() < mutationRate:
        i = random.choice(individuals)
        p.replaceIndividual(i, mu.mutateIndividual(i, p))

    return p
\end{lstlisting}

\pagebreak

\begin{itemize}
\item\textbf{worstIndividualMutation}: Questa funzione può eseguire una mutazione ma con la scelta del set di esercizi da cambiare, infatti viene individuato il set di esercizi con la fitness minore, successivamente viene richiamata la funzioen mutateIndividual.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def worstIndividualMutation(p: Population, mutationRate: float) -> Population:
    individuals = p.getIndividuals()
    minF = individuals[0].fitness()
    indice = 0
    for index, individual in enumerate(individuals):
        if minF > individual.fitness():
            minF = individual.fitness()
            indice = index

    if random.random() < mutationRate:
        i = p.getIndividuals()[indice]
        p.replaceIndividual(i, mu.mutateIndividual(i, p))

    return p
        \end{lstlisting}
    Queste 3 tipologie di mutazioni per funzionare utilizzano:

\begin{itemize}
\item\textbf{mutateEX}: Questa fuznione esegue uan ricerca casuale nel set di esercizi che ha ricevuto e sul DataBase per poi cambiare l'esercizio.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def mutateEx(i: Individual, p: Population) -> Individual:
    userId = p.getUser().getID()
    gen = p.getGeneration()
    oldEx = random.choice(i.getList())
    newEx = db.select_random_exercise(1, userId)[0]
    i.replaceExercise(oldEx, newEx, gen)
    evaluate(i, p.getUser())

    return i
\end{lstlisting}

\begin{itemize}
\item\textbf{mutateIndividual}: esegue una ricerca casuale nel DataBase di un numero di esercizi per un intero set per poi sostituirli e ricalcolare il valore fitness.
\end{itemize}

\begin{lstlisting}[language=Python, breaklines, no caption]
def mutateIndividual(i: Individual, p: Population):
    userId = p.getUser().getID()
    gen = p.getGeneration()
    newIndividual = Individual(*db.select_random_exercise(len(i.getList()), userId))
    evaluate(newIndividual, p.getUser())
    for ex in newIndividual.getList():
        ex.setGeneration(gen)

    return newIndividual
\end{lstlisting}

\pagebreak

\section{Considerazioni finali}
Siamo giunti alla conclusione di un lungo viaggio alla fine del quale ci riteniamo soddisfatti di quanto ottenuto poich´e sono stati raggiunti gli obiettivi che ci eravamo prefissati. Un aspetto di cui andiamo particolarmente fieri è la gestione in multiprocessign dell'algoritmo.

\subsection{Cosa abbiamo Imparato}
Grazie a questo progetto abbiamo potuto provare le conoscenze che abbiamo acquisito durante il corso di Intelligenza Artificiale e provare sulla pratica il nostro primo algoritmo di Intelligenza Artificiale, grazie a questa prova abbiamo imparato l'importanza dell'organizzazione e della stesura dei requisiti del progetto, prendendoci più tempo possibile per definire al meglio gli obiettivi da raggiungere, essendo stato utile dedicare molto tempo alla stesura e definizione della funzione di Fitness.
\pagebreak

\section{Glossario}

\begin{itemize}
\begin{itemize}
Termini speciali utilizzati:
\end{itemize}
\begin{itemize}
\item\textbf{Dataset}: Insieme di dati su cui l'algoritmo lavora.
\end{itemize}
\begin{itemize}
\item\textbf{DataBase}: Archivio di dati centralizzato in una macchina, su cui è possibile prellevarli o modificarli.
\end{itemize}
\begin{itemize}
\item\textbf{Algoritmo Genetico}: Algoritmo dell'Intelligenza Artificiale che simula il ciclo di vita di uan specie per raggiungere l'obiettivo.
\end{itemize}
\begin{itemize}
\item\textbf{SQL}: Linguaggio standardizzato per Database utilizzato per eseguire operazioni sui Database.
\end{itemize}
\begin{itemize}
\item\textbf{Fitness}: Valore utilizzato dall'Algoritmo Genetico per riconoscere la bontà di una soluzione da lui trovata.
\end{itemize}
\begin{itemize}
\item\textbf{Dizionario}:Struttura dati utilizzato in programmazione, formata dall'associazione di chiave valore.
\end{itemize}
\begin{itemize}
\item\textbf{Classe}: Costrutto di un linguaggio di programmazione usato come modello per creare oggetti.
\end{itemize}
\begin{itemize}
\item\textbf{Algoritmo}: Soluzione ad un problema strutturato da operazioni e condizioni.
\end{itemize}
\end{itemize}

\printindex

\end{document}
